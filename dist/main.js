(()=>{"use strict";var __webpack_modules__={384:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  p: () => (/* binding */ attackEnemy)\n});\n\n;// ./src/ship.js\nclass Ship {\n    #length\n    #hits = 0\n    constructor(length) {\n        this.#length = length\n    }\n\n    get length() {\n        return this.#length\n    }\n\n    get hits() {\n        return this.#hits\n    }\n\n    hit = () => this.#hits++\n\n    isSunk = () => this.#hits === this.#length\n}\n;// ./src/pubsub.js\nclass PubSub {\n    #events = {};\n\n    on(eventName, fn) {\n        this.#events[eventName] = this.#events[eventName] || [];\n        this.#events[eventName].push(fn);\n    }\n\n    off(eventName, fn) {\n        if (this.#events[eventName]) {\n            for (let i = 0; i < this.#events[eventName].length; i++) {\n                if (this.#events[eventName][i] === fn) {\n                    this.#events[eventName].splice(i, 1);\n                    break;\n                }\n            };\n        };\n    }\n\n    emit(eventName, data) {\n        if (this.#events[eventName]) {\n            this.#events[eventName].forEach((fn) => {\n                fn(data);\n            });\n        }\n    }\n\n    get list() {\n        return this.#events;\n    }\n};\n\nconst Events = new PubSub;\n;// ./src/game.js\n\n\n\nclass Gameboard {\n    #board = []\n    #attacked = new Map()\n    #sunkShips = []\n    #shipLocations = []\n\n    constructor(name) {\n        const ROWS = 10\n        const COLUMNS = 10\n        this.ships = [4, 3, 3, 2, 2, 2, 1, 1, 1, 1]\n        this.name = name\n\n        for (let i = 0; i < ROWS; i++) {\n        this.#board[i] = [];\n        for (let j = 0; j < COLUMNS; j++) {\n            this.#board[i].push(new Cell());\n        }}\n    }\n\n    get cells() {\n        return this.#board\n    }\n\n    get attackedCells() {\n        return this.#attacked\n    }\n\n    get sunkShips() {\n        return this.#sunkShips\n    }\n\n    printBoard = () => {\n        this.#board.forEach(row => {\n            let output = ''\n            row.forEach(cell => output += cell.value)\n            console.log(output)\n        })\n    }\n\n    placeShip = ([x, y], index, length, orientation) => {\n        if (orientation === 'x') {\n            for (let i = 0; i < length; i++) {\n                this.populate([x + i, y], index)\n                this.populate([x + i, y - 1], '=')\n                this.populate([x + i, y + 1], '=')\n                for (let j = -1; j < 2; j++) {\n                    this.populate([x - 1, y + j], '=')\n                    this.populate([x + length, y + j], '=')\n                }\n            }\n        } else {\n            for (let i = 0; i < length; i++) {\n                this.populate([x, y + i], index)\n                this.populate([x - 1, y + i], '=')\n                this.populate([x + 1, y + i], '=')\n                for (let j = -1; j < 2; j++) {\n                    this.populate([x + j, y - 1], '=')\n                    this.populate([x + j, y + length], '=')\n                }\n            }\n        }\n    }\n\n    isOnBoard = (x, y) => x >= 0 && x < 10 && y >= 0 && y < 10\n\n    isShip = (x, y) => Number.isInteger(this.getValue(x, y))\n\n    populate = ([x, y], value) => {\n        if (this.isOnBoard(x, y) && !this.isShip(x, y)) this.#board[y][x].value = value\n    } \n\n    getValue = (x, y) => this.#board[y][x].value\n\n    isValidPosition([x, y], length, orientation) {\n        for (let i = 0; i < length; i++) {\n            if (orientation === 'x') {\n                if (this.getValue(x + i, y) !== '_') return false\n            } else {\n                if (this.getValue(x, y + i) !== '_') return false\n            }\n        }\n        return true\n    }\n\n    generateShips = () => {\n        this.ships.forEach((length, index) => {\n            let ship = new Ship(length)\n            this.ships[index] = ship\n\n            let x, y, orientation\n            while (true) {\n                x = this.getRandomInt(11 - length)\n                y = this.getRandomInt(11 - length)\n                orientation = (this.getRandomInt(2) === 0) ? 'x' : 'y' \n                if (this.isValidPosition([x, y], length, orientation)) {\n                    this.placeShip([x, y], index, length, orientation)\n                    this.#shipLocations[index] = { x, y, length, orientation }\n                    break\n                }\n            }\n            // this.printBoard()\n            // console.log()\n        })\n    }\n\n    getRandomInt = (max) => Math.floor(Math.random() * max)\n\n    receiveAttack = (x, y) => {\n        let hash = x + y * 10\n        if (this.#attacked.has(hash)) return\n        this.#attacked.set(parseInt(hash), this.getValue(x, y))\n        if (this.isShip(x, y)) {\n            let attackedShip = this.getShip(x, y)\n            attackedShip.hit()\n            if (attackedShip.isSunk()) {\n                this.#sunkShips.push(attackedShip)\n                this.clearNeighbourCells(this.getValue(x, y))\n            }\n        }\n    }\n\n    clearNeighbourCells = (index) => {\n        let { x, y, length, orientation } = this.#shipLocations[index]\n        if (orientation === 'x') {\n            for (let i = 0; i < length; i++) {\n                this.clear(x + i, y - 1)\n                this.clear(x + i, y + 1)\n                for (let j = -1; j < 2; j++) {\n                    this.clear(x - 1, y + j)\n                    this.clear(x + length, y + j)\n                }\n            }\n        } else {\n            for (let i = 0; i < length; i++) {\n                this.clear(x - 1, y + i)\n                this.clear(x + 1, y + i)\n                for (let j = -1; j < 2; j++) {\n                    this.clear(x + j, y - 1)\n                    this.clear(x + j, y + length)\n                }\n            }\n        }\n    }\n\n    getShip = (x, y) => this.ships[this.getValue(x, y)]\n    \n    clear = (x, y) => {\n        let hash = x + y * 10\n        if (this.isOnBoard(x, y) && !this.#attacked.has(hash)) {\n            Events.emit('updateCell', [this.name, x, y, 'cleared'])\n            this.#attacked.set(hash, this.getValue(x, y))\n        }\n    }\n\n    allShipsSunk = () => this.#sunkShips.length === this.ships.length\n}\n\nclass Cell {\n    constructor() {\n        this.value = '_'\n    }\n}\n\nlet cat = new Gameboard()\ncat.generateShips()\n\n;// ./src/player.js\n\n\n\nclass Player {\n    constructor(name = 'player', robot = 'false') {\n        this.name = name\n        this.board = new Gameboard(this.name)\n        this.board.generateShips()\n    }\n\n    attack = (enemy, x, y) => {\n        enemy.board.receiveAttack(x, y)\n\n        if (enemy.board.isShip(x, y)) {\n            Events.emit('updateCell', [enemy.name, x, y, 'hit'])\n            if (enemy.board.allShipsSunk()) Events.emit('win', this.name)\n            Events.emit('hit')\n            return true\n        } else {\n            Events.emit('updateCell', [enemy.name, x, y, 'miss'])\n            Events.emit('miss')\n            return false\n        }\n    }\n}\n\n;// ./src/render.js\n\n\nconst $ = (id) => document.getElementById(id)\n\nfunction render(board) {\n    renderCells(board, false)\n}\n\nfunction renderAsHidden(board) {\n    renderCells(board, true)\n}\n\nfunction renderCells(board, hidden) {\n    const gameBoard = document.createElement('div')\n    gameBoard.classList.add('board')\n    $('game').appendChild(gameBoard)\n\n    if (hidden) {\n        gameBoard.classList.add('enemy')\n    } else {\n        gameBoard.classList.add('player')\n    }\n\n    board.forEach((row, rowIndex) => {\n        let rowDiv = document.createElement('div')\n        gameBoard.appendChild(rowDiv)\n        row.forEach((cell, columnIndex) => {\n            let cellDiv = document.createElement('div')\n            cellDiv.dataset.y = rowIndex\n            cellDiv.dataset.x = columnIndex\n            rowDiv.appendChild(cellDiv)\n            \n            if (hidden) {\n                cellDiv.classList.add('clickableCell')\n                cellDiv.addEventListener('click', attackEnemy)\n            } else {\n                let className = 'empty'\n                if (Number.isInteger(cell.value)) className = 'ship'\n                cellDiv.classList.add(className)\n            }\n        })\n    })\n}\n\n(function renderer() {\n    Events.on('win', (player) => {console.log(`${player} won`)})\n    Events.on('updateCell', ([name, x, y, state]) => {\n        let div = document.querySelector(`.${name} [data-x=\"${x}\"][data-y=\"${y}\"]`)\n        div.classList.add(state)\n    })\n})();\n\n(function soundBoard() {\n    Events.on('hit', () => {playSound('hit')})\n    Events.on('miss', () => {playSound('miss')})\n    Events.on('sink', () => {playSound('sink')})\n})()\n\nfunction playSound(sound) {\n    $(sound).currentTime = 0;\n    $(sound).play();\n}\n;// ./src/index.js\n\n\n\n\n\nlet user = new Player('player')\nlet robot = new Player('enemy', true)\nlet turn = 'player'\nlet memory = false\nlet win = false\nlet queue = [\n    {x: +1, y: 0, times: 1, orientation: 'x'},\n    {x: -1, y: 0, times: 1, orientation: 'x'},\n    {x: 0, y: +1, times: 1, orientation: 'y'},\n    {x: 0, y: -1, times: 1, orientation: 'y'}\n]\nEvents.on('win', () => {win = true})\n\nrender(user.board.cells)\nrenderAsHidden(robot.board.cells)\n\nfunction attackEnemy(e) {\n    let { x, y } = e.srcElement.dataset\n    x = parseInt(x)\n    y = parseInt(y)\n    let hash = x + y * 10\n\n    if (turn === 'player' && !robot.board.attackedCells.has(hash) && !win) {\n        let shipHit = user.attack(robot, x, y)\n        if (shipHit) return\n        turn = 'enemy'\n        letEnemyAttack()\n    }\n}\n\nfunction letEnemyAttack() {\n    let x\n    let y\n    if (memory) {\n        letEnemyTargetShip()\n        return\n    }\n\n    while (true) {\n            x = getRandomInt(10)\n            y = getRandomInt(10)\n            if (!user.board.attackedCells.has(x + y * 10)) break\n    }\n\n    setTimeout(() => {\n        let shipHit = robot.attack(user, x, y)\n        if (shipHit) {\n            if (win) return\n            memory = {x: x, y: y, ship: user.board.getShip(x, y), orientation: false, queue: shuffle([...queue])}\n            if (memory.ship.isSunk()) {\n                memory = false\n                Events.emit('sunk')\n                letEnemyAttack()\n            } else {\n                letEnemyTargetShip()\n            }\n            return\n        }\n        turn = 'player'\n    }, Math.random() * 500 + 500)\n}\n\nfunction letEnemyTargetShip() {\n    let direction, x, y\n    while(true) {\n        direction = memory.queue.shift()\n        x = memory.x + direction.x * direction.times\n        y = memory.y + direction.y * direction.times\n        if (user.board.isOnBoard(x, y) && !user.board.attackedCells.has(x + y * 10)) {\n            if (memory.orientation) {\n                if (memory.orientation === direction.orientation) break\n            } else {\n                break\n            }\n        }\n    }\n\n    setTimeout(() => {\n        let shipHit = robot.attack(user, x, y)\n        if (shipHit) {\n            memory.queue.push({x: direction.x, y: direction.y, times: direction.times + 1, orientation: direction.orientation})\n            if (!memory.orientation) memory.orientation = direction.orientation\n            if (win) return\n            if (memory.ship.isSunk()) {\n                memory = false\n                Events.emit('sunk')\n                letEnemyAttack()\n            } else {\n                letEnemyTargetShip()\n            }\n            return\n        }\n        turn = 'player'\n    }, Math.random() * 500 + 500)\n}\n\nlet getRandomInt = (max) => Math.floor(Math.random() * max)\n\nfunction shuffle(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = getRandomInt(i + 1);\n        [array[i], array[j]] = [array[j], array[i]]\n    }\n    return array\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LCJ3ZWJwYWNrOi8vd2VicGFjay8uL3NyYy9wdWJzdWIuanM/NDVmOCIsIndlYnBhY2s6Ly93ZWJwYWNrLy4vc3JjL2dhbWUuanM/YjliMiIsIndlYnBhY2s6Ly93ZWJwYWNrLy4vc3JjL3BsYXllci5qcz8zOGU2Iiwid2VicGFjazovL3dlYnBhY2svLi9zcmMvcmVuZGVyLmpzPzhlNmEiLCJ3ZWJwYWNrOi8vd2VicGFjay8uL3NyYy9pbmRleC5qcz8wMDkzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBTaGlwIHtcbiAgICAjbGVuZ3RoXG4gICAgI2hpdHMgPSAwXG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuI2xlbmd0aCA9IGxlbmd0aFxuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNsZW5ndGhcbiAgICB9XG5cbiAgICBnZXQgaGl0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2hpdHNcbiAgICB9XG5cbiAgICBoaXQgPSAoKSA9PiB0aGlzLiNoaXRzKytcblxuICAgIGlzU3VuayA9ICgpID0+IHRoaXMuI2hpdHMgPT09IHRoaXMuI2xlbmd0aFxufSIsImNsYXNzIFB1YlN1YiB7XG4gICAgI2V2ZW50cyA9IHt9O1xuXG4gICAgb24oZXZlbnROYW1lLCBmbikge1xuICAgICAgICB0aGlzLiNldmVudHNbZXZlbnROYW1lXSA9IHRoaXMuI2V2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuICAgICAgICB0aGlzLiNldmVudHNbZXZlbnROYW1lXS5wdXNoKGZuKTtcbiAgICB9XG5cbiAgICBvZmYoZXZlbnROYW1lLCBmbikge1xuICAgICAgICBpZiAodGhpcy4jZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jZXZlbnRzW2V2ZW50TmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jZXZlbnRzW2V2ZW50TmFtZV1baV0gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2V2ZW50c1tldmVudE5hbWVdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBlbWl0KGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICBpZiAodGhpcy4jZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuI2V2ZW50c1tldmVudE5hbWVdLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICAgICAgICAgICAgZm4oZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBsaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZXZlbnRzO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBFdmVudHMgPSBuZXcgUHViU3ViOyIsImltcG9ydCB7IFNoaXAgfSBmcm9tICcuL3NoaXAuanMnXG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuL3B1YnN1Yi5qcydcblxuZXhwb3J0IGNsYXNzIEdhbWVib2FyZCB7XG4gICAgI2JvYXJkID0gW11cbiAgICAjYXR0YWNrZWQgPSBuZXcgTWFwKClcbiAgICAjc3Vua1NoaXBzID0gW11cbiAgICAjc2hpcExvY2F0aW9ucyA9IFtdXG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIGNvbnN0IFJPV1MgPSAxMFxuICAgICAgICBjb25zdCBDT0xVTU5TID0gMTBcbiAgICAgICAgdGhpcy5zaGlwcyA9IFs0LCAzLCAzLCAyLCAyLCAyLCAxLCAxLCAxLCAxXVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBST1dTOyBpKyspIHtcbiAgICAgICAgdGhpcy4jYm9hcmRbaV0gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBDT0xVTU5TOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMuI2JvYXJkW2ldLnB1c2gobmV3IENlbGwoKSk7XG4gICAgICAgIH19XG4gICAgfVxuXG4gICAgZ2V0IGNlbGxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYm9hcmRcbiAgICB9XG5cbiAgICBnZXQgYXR0YWNrZWRDZWxscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2F0dGFja2VkXG4gICAgfVxuXG4gICAgZ2V0IHN1bmtTaGlwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3N1bmtTaGlwc1xuICAgIH1cblxuICAgIHByaW50Qm9hcmQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2JvYXJkLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGxldCBvdXRwdXQgPSAnJ1xuICAgICAgICAgICAgcm93LmZvckVhY2goY2VsbCA9PiBvdXRwdXQgKz0gY2VsbC52YWx1ZSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG91dHB1dClcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwbGFjZVNoaXAgPSAoW3gsIHldLCBpbmRleCwgbGVuZ3RoLCBvcmllbnRhdGlvbikgPT4ge1xuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICd4Jykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdWxhdGUoW3ggKyBpLCB5XSwgaW5kZXgpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZShbeCArIGksIHkgLSAxXSwgJz0nKVxuICAgICAgICAgICAgICAgIHRoaXMucG9wdWxhdGUoW3ggKyBpLCB5ICsgMV0sICc9JylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLTE7IGogPCAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZShbeCAtIDEsIHkgKyBqXSwgJz0nKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVsYXRlKFt4ICsgbGVuZ3RoLCB5ICsgal0sICc9JylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZShbeCwgeSArIGldLCBpbmRleClcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVsYXRlKFt4IC0gMSwgeSArIGldLCAnPScpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZShbeCArIDEsIHkgKyBpXSwgJz0nKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAtMTsgaiA8IDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVsYXRlKFt4ICsgaiwgeSAtIDFdLCAnPScpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdWxhdGUoW3ggKyBqLCB5ICsgbGVuZ3RoXSwgJz0nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzT25Cb2FyZCA9ICh4LCB5KSA9PiB4ID49IDAgJiYgeCA8IDEwICYmIHkgPj0gMCAmJiB5IDwgMTBcblxuICAgIGlzU2hpcCA9ICh4LCB5KSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHRoaXMuZ2V0VmFsdWUoeCwgeSkpXG5cbiAgICBwb3B1bGF0ZSA9IChbeCwgeV0sIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzT25Cb2FyZCh4LCB5KSAmJiAhdGhpcy5pc1NoaXAoeCwgeSkpIHRoaXMuI2JvYXJkW3ldW3hdLnZhbHVlID0gdmFsdWVcbiAgICB9IFxuXG4gICAgZ2V0VmFsdWUgPSAoeCwgeSkgPT4gdGhpcy4jYm9hcmRbeV1beF0udmFsdWVcblxuICAgIGlzVmFsaWRQb3NpdGlvbihbeCwgeV0sIGxlbmd0aCwgb3JpZW50YXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAneCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRWYWx1ZSh4ICsgaSwgeSkgIT09ICdfJykgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldFZhbHVlKHgsIHkgKyBpKSAhPT0gJ18nKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGdlbmVyYXRlU2hpcHMgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2hpcHMuZm9yRWFjaCgobGVuZ3RoLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNoaXAgPSBuZXcgU2hpcChsZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnNoaXBzW2luZGV4XSA9IHNoaXBcblxuICAgICAgICAgICAgbGV0IHgsIHksIG9yaWVudGF0aW9uXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHggPSB0aGlzLmdldFJhbmRvbUludCgxMSAtIGxlbmd0aClcbiAgICAgICAgICAgICAgICB5ID0gdGhpcy5nZXRSYW5kb21JbnQoMTEgLSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgb3JpZW50YXRpb24gPSAodGhpcy5nZXRSYW5kb21JbnQoMikgPT09IDApID8gJ3gnIDogJ3knIFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRQb3NpdGlvbihbeCwgeV0sIGxlbmd0aCwgb3JpZW50YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxhY2VTaGlwKFt4LCB5XSwgaW5kZXgsIGxlbmd0aCwgb3JpZW50YXRpb24pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3NoaXBMb2NhdGlvbnNbaW5kZXhdID0geyB4LCB5LCBsZW5ndGgsIG9yaWVudGF0aW9uIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzLnByaW50Qm9hcmQoKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGdldFJhbmRvbUludCA9IChtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heClcblxuICAgIHJlY2VpdmVBdHRhY2sgPSAoeCwgeSkgPT4ge1xuICAgICAgICBsZXQgaGFzaCA9IHggKyB5ICogMTBcbiAgICAgICAgaWYgKHRoaXMuI2F0dGFja2VkLmhhcyhoYXNoKSkgcmV0dXJuXG4gICAgICAgIHRoaXMuI2F0dGFja2VkLnNldChwYXJzZUludChoYXNoKSwgdGhpcy5nZXRWYWx1ZSh4LCB5KSlcbiAgICAgICAgaWYgKHRoaXMuaXNTaGlwKHgsIHkpKSB7XG4gICAgICAgICAgICBsZXQgYXR0YWNrZWRTaGlwID0gdGhpcy5nZXRTaGlwKHgsIHkpXG4gICAgICAgICAgICBhdHRhY2tlZFNoaXAuaGl0KClcbiAgICAgICAgICAgIGlmIChhdHRhY2tlZFNoaXAuaXNTdW5rKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNzdW5rU2hpcHMucHVzaChhdHRhY2tlZFNoaXApXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhck5laWdoYm91ckNlbGxzKHRoaXMuZ2V0VmFsdWUoeCwgeSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhck5laWdoYm91ckNlbGxzID0gKGluZGV4KSA9PiB7XG4gICAgICAgIGxldCB7IHgsIHksIGxlbmd0aCwgb3JpZW50YXRpb24gfSA9IHRoaXMuI3NoaXBMb2NhdGlvbnNbaW5kZXhdXG4gICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcih4ICsgaSwgeSAtIDEpXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcih4ICsgaSwgeSArIDEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC0xOyBqIDwgMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoeCAtIDEsIHkgKyBqKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKHggKyBsZW5ndGgsIHkgKyBqKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKHggLSAxLCB5ICsgaSlcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKHggKyAxLCB5ICsgaSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gLTE7IGogPCAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcih4ICsgaiwgeSAtIDEpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoeCArIGosIHkgKyBsZW5ndGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0U2hpcCA9ICh4LCB5KSA9PiB0aGlzLnNoaXBzW3RoaXMuZ2V0VmFsdWUoeCwgeSldXG4gICAgXG4gICAgY2xlYXIgPSAoeCwgeSkgPT4ge1xuICAgICAgICBsZXQgaGFzaCA9IHggKyB5ICogMTBcbiAgICAgICAgaWYgKHRoaXMuaXNPbkJvYXJkKHgsIHkpICYmICF0aGlzLiNhdHRhY2tlZC5oYXMoaGFzaCkpIHtcbiAgICAgICAgICAgIEV2ZW50cy5lbWl0KCd1cGRhdGVDZWxsJywgW3RoaXMubmFtZSwgeCwgeSwgJ2NsZWFyZWQnXSlcbiAgICAgICAgICAgIHRoaXMuI2F0dGFja2VkLnNldChoYXNoLCB0aGlzLmdldFZhbHVlKHgsIHkpKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWxsU2hpcHNTdW5rID0gKCkgPT4gdGhpcy4jc3Vua1NoaXBzLmxlbmd0aCA9PT0gdGhpcy5zaGlwcy5sZW5ndGhcbn1cblxuZXhwb3J0IGNsYXNzIENlbGwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gJ18nXG4gICAgfVxufVxuXG5sZXQgY2F0ID0gbmV3IEdhbWVib2FyZCgpXG5jYXQuZ2VuZXJhdGVTaGlwcygpXG4iLCJpbXBvcnQgeyBHYW1lYm9hcmQsIENlbGwgfSBmcm9tICcuL2dhbWUuanMnXG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tIFwiLi9wdWJzdWIuanNcIjtcblxuZXhwb3J0IGNsYXNzIFBsYXllciB7XG4gICAgY29uc3RydWN0b3IobmFtZSA9ICdwbGF5ZXInLCByb2JvdCA9ICdmYWxzZScpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZVxuICAgICAgICB0aGlzLmJvYXJkID0gbmV3IEdhbWVib2FyZCh0aGlzLm5hbWUpXG4gICAgICAgIHRoaXMuYm9hcmQuZ2VuZXJhdGVTaGlwcygpXG4gICAgfVxuXG4gICAgYXR0YWNrID0gKGVuZW15LCB4LCB5KSA9PiB7XG4gICAgICAgIGVuZW15LmJvYXJkLnJlY2VpdmVBdHRhY2soeCwgeSlcblxuICAgICAgICBpZiAoZW5lbXkuYm9hcmQuaXNTaGlwKHgsIHkpKSB7XG4gICAgICAgICAgICBFdmVudHMuZW1pdCgndXBkYXRlQ2VsbCcsIFtlbmVteS5uYW1lLCB4LCB5LCAnaGl0J10pXG4gICAgICAgICAgICBpZiAoZW5lbXkuYm9hcmQuYWxsU2hpcHNTdW5rKCkpIEV2ZW50cy5lbWl0KCd3aW4nLCB0aGlzLm5hbWUpXG4gICAgICAgICAgICBFdmVudHMuZW1pdCgnaGl0JylcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFdmVudHMuZW1pdCgndXBkYXRlQ2VsbCcsIFtlbmVteS5uYW1lLCB4LCB5LCAnbWlzcyddKVxuICAgICAgICAgICAgRXZlbnRzLmVtaXQoJ21pc3MnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBhdHRhY2tFbmVteSB9IGZyb20gJy4vaW5kZXguanMnXG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuL3B1YnN1Yi5qcydcbmNvbnN0ICQgPSAoaWQpID0+IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKGJvYXJkKSB7XG4gICAgcmVuZGVyQ2VsbHMoYm9hcmQsIGZhbHNlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyQXNIaWRkZW4oYm9hcmQpIHtcbiAgICByZW5kZXJDZWxscyhib2FyZCwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2VsbHMoYm9hcmQsIGhpZGRlbikge1xuICAgIGNvbnN0IGdhbWVCb2FyZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgZ2FtZUJvYXJkLmNsYXNzTGlzdC5hZGQoJ2JvYXJkJylcbiAgICAkKCdnYW1lJykuYXBwZW5kQ2hpbGQoZ2FtZUJvYXJkKVxuXG4gICAgaWYgKGhpZGRlbikge1xuICAgICAgICBnYW1lQm9hcmQuY2xhc3NMaXN0LmFkZCgnZW5lbXknKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdhbWVCb2FyZC5jbGFzc0xpc3QuYWRkKCdwbGF5ZXInKVxuICAgIH1cblxuICAgIGJvYXJkLmZvckVhY2goKHJvdywgcm93SW5kZXgpID0+IHtcbiAgICAgICAgbGV0IHJvd0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGdhbWVCb2FyZC5hcHBlbmRDaGlsZChyb3dEaXYpXG4gICAgICAgIHJvdy5mb3JFYWNoKChjZWxsLCBjb2x1bW5JbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNlbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgICAgY2VsbERpdi5kYXRhc2V0LnkgPSByb3dJbmRleFxuICAgICAgICAgICAgY2VsbERpdi5kYXRhc2V0LnggPSBjb2x1bW5JbmRleFxuICAgICAgICAgICAgcm93RGl2LmFwcGVuZENoaWxkKGNlbGxEaXYpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBjZWxsRGl2LmNsYXNzTGlzdC5hZGQoJ2NsaWNrYWJsZUNlbGwnKVxuICAgICAgICAgICAgICAgIGNlbGxEaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhdHRhY2tFbmVteSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNsYXNzTmFtZSA9ICdlbXB0eSdcbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihjZWxsLnZhbHVlKSkgY2xhc3NOYW1lID0gJ3NoaXAnXG4gICAgICAgICAgICAgICAgY2VsbERpdi5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG4oZnVuY3Rpb24gcmVuZGVyZXIoKSB7XG4gICAgRXZlbnRzLm9uKCd3aW4nLCAocGxheWVyKSA9PiB7Y29uc29sZS5sb2coYCR7cGxheWVyfSB3b25gKX0pXG4gICAgRXZlbnRzLm9uKCd1cGRhdGVDZWxsJywgKFtuYW1lLCB4LCB5LCBzdGF0ZV0pID0+IHtcbiAgICAgICAgbGV0IGRpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYC4ke25hbWV9IFtkYXRhLXg9XCIke3h9XCJdW2RhdGEteT1cIiR7eX1cIl1gKVxuICAgICAgICBkaXYuY2xhc3NMaXN0LmFkZChzdGF0ZSlcbiAgICB9KVxufSkoKTtcblxuKGZ1bmN0aW9uIHNvdW5kQm9hcmQoKSB7XG4gICAgRXZlbnRzLm9uKCdoaXQnLCAoKSA9PiB7cGxheVNvdW5kKCdoaXQnKX0pXG4gICAgRXZlbnRzLm9uKCdtaXNzJywgKCkgPT4ge3BsYXlTb3VuZCgnbWlzcycpfSlcbiAgICBFdmVudHMub24oJ3NpbmsnLCAoKSA9PiB7cGxheVNvdW5kKCdzaW5rJyl9KVxufSkoKVxuXG5mdW5jdGlvbiBwbGF5U291bmQoc291bmQpIHtcbiAgICAkKHNvdW5kKS5jdXJyZW50VGltZSA9IDA7XG4gICAgJChzb3VuZCkucGxheSgpO1xufSIsImltcG9ydCAnLi9zdHlsZXMuY3NzJ1xuaW1wb3J0IHsgUGxheWVyIH0gZnJvbSAnLi9wbGF5ZXIuanMnXG5pbXBvcnQgeyByZW5kZXIsIHJlbmRlckFzSGlkZGVuIH0gZnJvbSAnLi9yZW5kZXIuanMnXG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tIFwiLi9wdWJzdWIuanNcIjtcblxubGV0IHVzZXIgPSBuZXcgUGxheWVyKCdwbGF5ZXInKVxubGV0IHJvYm90ID0gbmV3IFBsYXllcignZW5lbXknLCB0cnVlKVxubGV0IHR1cm4gPSAncGxheWVyJ1xubGV0IG1lbW9yeSA9IGZhbHNlXG5sZXQgd2luID0gZmFsc2VcbmxldCBxdWV1ZSA9IFtcbiAgICB7eDogKzEsIHk6IDAsIHRpbWVzOiAxLCBvcmllbnRhdGlvbjogJ3gnfSxcbiAgICB7eDogLTEsIHk6IDAsIHRpbWVzOiAxLCBvcmllbnRhdGlvbjogJ3gnfSxcbiAgICB7eDogMCwgeTogKzEsIHRpbWVzOiAxLCBvcmllbnRhdGlvbjogJ3knfSxcbiAgICB7eDogMCwgeTogLTEsIHRpbWVzOiAxLCBvcmllbnRhdGlvbjogJ3knfVxuXVxuRXZlbnRzLm9uKCd3aW4nLCAoKSA9PiB7d2luID0gdHJ1ZX0pXG5cbnJlbmRlcih1c2VyLmJvYXJkLmNlbGxzKVxucmVuZGVyQXNIaWRkZW4ocm9ib3QuYm9hcmQuY2VsbHMpXG5cbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2tFbmVteShlKSB7XG4gICAgbGV0IHsgeCwgeSB9ID0gZS5zcmNFbGVtZW50LmRhdGFzZXRcbiAgICB4ID0gcGFyc2VJbnQoeClcbiAgICB5ID0gcGFyc2VJbnQoeSlcbiAgICBsZXQgaGFzaCA9IHggKyB5ICogMTBcblxuICAgIGlmICh0dXJuID09PSAncGxheWVyJyAmJiAhcm9ib3QuYm9hcmQuYXR0YWNrZWRDZWxscy5oYXMoaGFzaCkgJiYgIXdpbikge1xuICAgICAgICBsZXQgc2hpcEhpdCA9IHVzZXIuYXR0YWNrKHJvYm90LCB4LCB5KVxuICAgICAgICBpZiAoc2hpcEhpdCkgcmV0dXJuXG4gICAgICAgIHR1cm4gPSAnZW5lbXknXG4gICAgICAgIGxldEVuZW15QXR0YWNrKClcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxldEVuZW15QXR0YWNrKCkge1xuICAgIGxldCB4XG4gICAgbGV0IHlcbiAgICBpZiAobWVtb3J5KSB7XG4gICAgICAgIGxldEVuZW15VGFyZ2V0U2hpcCgpXG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB4ID0gZ2V0UmFuZG9tSW50KDEwKVxuICAgICAgICAgICAgeSA9IGdldFJhbmRvbUludCgxMClcbiAgICAgICAgICAgIGlmICghdXNlci5ib2FyZC5hdHRhY2tlZENlbGxzLmhhcyh4ICsgeSAqIDEwKSkgYnJlYWtcbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGV0IHNoaXBIaXQgPSByb2JvdC5hdHRhY2sodXNlciwgeCwgeSlcbiAgICAgICAgaWYgKHNoaXBIaXQpIHtcbiAgICAgICAgICAgIGlmICh3aW4pIHJldHVyblxuICAgICAgICAgICAgbWVtb3J5ID0ge3g6IHgsIHk6IHksIHNoaXA6IHVzZXIuYm9hcmQuZ2V0U2hpcCh4LCB5KSwgb3JpZW50YXRpb246IGZhbHNlLCBxdWV1ZTogc2h1ZmZsZShbLi4ucXVldWVdKX1cbiAgICAgICAgICAgIGlmIChtZW1vcnkuc2hpcC5pc1N1bmsoKSkge1xuICAgICAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgRXZlbnRzLmVtaXQoJ3N1bmsnKVxuICAgICAgICAgICAgICAgIGxldEVuZW15QXR0YWNrKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0RW5lbXlUYXJnZXRTaGlwKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHR1cm4gPSAncGxheWVyJ1xuICAgIH0sIE1hdGgucmFuZG9tKCkgKiA1MDAgKyA1MDApXG59XG5cbmZ1bmN0aW9uIGxldEVuZW15VGFyZ2V0U2hpcCgpIHtcbiAgICBsZXQgZGlyZWN0aW9uLCB4LCB5XG4gICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBkaXJlY3Rpb24gPSBtZW1vcnkucXVldWUuc2hpZnQoKVxuICAgICAgICB4ID0gbWVtb3J5LnggKyBkaXJlY3Rpb24ueCAqIGRpcmVjdGlvbi50aW1lc1xuICAgICAgICB5ID0gbWVtb3J5LnkgKyBkaXJlY3Rpb24ueSAqIGRpcmVjdGlvbi50aW1lc1xuICAgICAgICBpZiAodXNlci5ib2FyZC5pc09uQm9hcmQoeCwgeSkgJiYgIXVzZXIuYm9hcmQuYXR0YWNrZWRDZWxscy5oYXMoeCArIHkgKiAxMCkpIHtcbiAgICAgICAgICAgIGlmIChtZW1vcnkub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAobWVtb3J5Lm9yaWVudGF0aW9uID09PSBkaXJlY3Rpb24ub3JpZW50YXRpb24pIGJyZWFrXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGV0IHNoaXBIaXQgPSByb2JvdC5hdHRhY2sodXNlciwgeCwgeSlcbiAgICAgICAgaWYgKHNoaXBIaXQpIHtcbiAgICAgICAgICAgIG1lbW9yeS5xdWV1ZS5wdXNoKHt4OiBkaXJlY3Rpb24ueCwgeTogZGlyZWN0aW9uLnksIHRpbWVzOiBkaXJlY3Rpb24udGltZXMgKyAxLCBvcmllbnRhdGlvbjogZGlyZWN0aW9uLm9yaWVudGF0aW9ufSlcbiAgICAgICAgICAgIGlmICghbWVtb3J5Lm9yaWVudGF0aW9uKSBtZW1vcnkub3JpZW50YXRpb24gPSBkaXJlY3Rpb24ub3JpZW50YXRpb25cbiAgICAgICAgICAgIGlmICh3aW4pIHJldHVyblxuICAgICAgICAgICAgaWYgKG1lbW9yeS5zaGlwLmlzU3VuaygpKSB7XG4gICAgICAgICAgICAgICAgbWVtb3J5ID0gZmFsc2VcbiAgICAgICAgICAgICAgICBFdmVudHMuZW1pdCgnc3VuaycpXG4gICAgICAgICAgICAgICAgbGV0RW5lbXlBdHRhY2soKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXRFbmVteVRhcmdldFNoaXAoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdHVybiA9ICdwbGF5ZXInXG4gICAgfSwgTWF0aC5yYW5kb20oKSAqIDUwMCArIDUwMClcbn1cblxubGV0IGdldFJhbmRvbUludCA9IChtYXgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heClcblxuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGogPSBnZXRSYW5kb21JbnQoaSArIDEpO1xuICAgICAgICBbYXJyYXlbaV0sIGFycmF5W2pdXSA9IFthcnJheVtqXSwgYXJyYXlbaV1dXG4gICAgfVxuICAgIHJldHVybiBhcnJheVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///384\n")}},__webpack_require__={d:(g,I)=>{for(var C in I)__webpack_require__.o(I,C)&&!__webpack_require__.o(g,C)&&Object.defineProperty(g,C,{enumerable:!0,get:I[C]})},o:(g,I)=>Object.prototype.hasOwnProperty.call(g,I)},__webpack_exports__={};__webpack_modules__[384](0,__webpack_exports__,__webpack_require__)})();